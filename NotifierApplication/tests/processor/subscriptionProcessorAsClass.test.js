// SubscriptionProcessorAsClass = require("../../processor/SubscriptionProcessorAsClass");

// jest.mock('../../services/subscriptions');

// // beforeAll(() => {
// //     // Set up some mocked out file info before each test
// //     jest.mock('../../services/subscriptions');
// // });

// afterAll(() => {
//     jest.restoreAllMocks;
// });

// // jest.mock('../../processor/subscriptionProcessor', function () {
// //     const originalModule = jest.requireActual('../../processor/subscriptionProcessor');
// //     originalModule.createChannelProcessors = function () { return new Map();},
// //     originalModule.determineChannelMap = function () { return new Map();}
// //     return originalModule
// // });

// // beforeEach(() => {
// //     // Set up some mocked out file info before each test
// //     //require('../../services/subscriptions').__setMockFiles(MOCK_FILE_INFO);
// //     jest.mock('../../services/subscriptions');
// //   }
// // );

test('test', () => {

//     //jest.mock('../../services/subscriptions');

//     let processor = new SubscriptionProcessorAsClass();
//     jest.spyOn(SubscriptionProcessorAsClass.prototype, 'determineChannelMap').mockImplementation(function() {return new Map();});
//     jest.spyOn(SubscriptionProcessorAsClass.prototype, 'createChannelProcessors').mockImplementation(function() {return new Map();});

//     //invoke the test
//     let result = processor.getProcessorsForActiveSubscriptions();

//     console.log(result);
//     //verify the outcome
//     expect(result).toEqual(new Map());
} );

